#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <cstdlib>
using namespace std;

class Complex {
public:
    double real;
    double imag;

    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    double magnitude() const {
        return sqrt(real * real + imag * imag);
    }

    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << "(" << c.real << ", " << c.imag << ")";
        return os;
    }

    bool operator<(const Complex& c) const {
        return this->magnitude() < c.magnitude();
    }

    bool operator==(const Complex& c) const {
        return (fabs(real - c.real) < 1e-6 && fabs(imag - c.imag) < 1e-6);
    }
};

class ComplexVector {
private:
    vector<Complex> data;

public:
    void generateRandom(int n) {
        srand(static_cast<unsigned>(time(nullptr)));
        for (int i = 0; i < n; ++i) {
            double r = (rand() % 101) - 50;
            double im = (rand() % 101) - 50;
            data.emplace_back(r, im);
        }
    }

    void print() const {
        for (const auto& c : data)
            cout << c << " ";
        cout << endl;
    }

    void insert(const Complex& c) {
        data.push_back(c);
    }

    void remove(const Complex& c) {
        auto it = std::remove(data.begin(), data.end(), c);
        data.erase(it, data.end());
    }

    void unique() {
        std::sort(data.begin(), data.end(), [](const Complex& a, const Complex& b) {
            if (a.real == b.real) return a.imag < b.imag;
            return a.real < b.real;
        });
        auto it = std::unique(data.begin(), data.end(), [](const Complex& a, const Complex& b) {
            return (fabs(a.real - b.real) < 1e-6 && fabs(a.imag - b.imag) < 1e-6);
        });
        data.erase(it, data.end());
    }

    void sortByMagnitude() {
        std::sort(data.begin(), data.end(), [](const Complex& a, const Complex& b) {
            return a.magnitude() < b.magnitude();
        });
    }

    void bubbleSort() {
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j + 1 < data.size() - i; ++j) {
                if (data[j + 1] < data[j])
                    std::swap(data[j], data[j + 1]);
            }
        }
    }

    void merge(int left, int mid, int right) {
        vector<Complex> temp;
        int i = left, j = mid + 1;
        while (i <= mid && j <= right) {
            if (data[i].magnitude() < data[j].magnitude())
                temp.push_back(data[i++]);
            else
                temp.push_back(data[j++]);
        }
        while (i <= mid) temp.push_back(data[i++]);
        while (j <= right) temp.push_back(data[j++]);
        for (int k = 0; k < (int)temp.size(); ++k)
            data[left + k] = temp[k];
    }

    void mergeSortHelper(int left, int right) {
        if (left >= right) return;
        int mid = left + (right - left) / 2;
        mergeSortHelper(left, mid);
        mergeSortHelper(mid + 1, right);
        merge(left, mid, right);
    }

    void mergeSort() {
        if (!data.empty())
            mergeSortHelper(0, (int)data.size() - 1);
    }

    vector<Complex> queryByMagnitude(double m1, double m2) const {
        vector<Complex> result;
        for (const auto& c : data) {
            double mag = c.magnitude();
            if (mag >= m1 && mag <= m2)
                result.push_back(c);
        }
        return result;
    }
};

int main() {
    ComplexVector vec;
    vec.generateRandom(12);
    cout << "原始复数向量：" << endl;
    vec.print();

    vec.insert(Complex(1, 1));
    cout << "\n插入 (1,1) 后：" << endl;
    vec.print();

    vec.remove(Complex(1, 1));
    cout << "\n删除 (1,1) 后：" << endl;
    vec.print();

    vec.insert(Complex(5, 5));
    vec.insert(Complex(5, 5));
    cout << "\n插入重复 (5,5) 后：" << endl;
    vec.print();

    vec.unique();
    cout << "\n去重后：" << endl;
    vec.print();

    ComplexVector vec1 = vec, vec2 = vec;
    clock_t start, end;

    start = clock();
    vec1.bubbleSort();
    end = clock();
    cout << "\n冒泡排序耗时: " << double(end - start) / CLOCKS_PER_SEC << " 秒" << endl;

    start = clock();
    vec2.mergeSort();
    end = clock();
    cout << "归并排序耗时: " << double(end - start) / CLOCKS_PER_SEC << " 秒" << endl;

    cout << "\n归并排序后：" << endl;
    vec2.print();

    double m1 = 10, m2 = 50;
    cout << "\n查询模在 [" << m1 << ", " << m2 << "] 的复数：" << endl;
    vector<Complex> result = vec2.queryByMagnitude(m1, m2);
    for (const auto& c : result)
        cout << c << " ";
    cout << endl;

    return 0;
}
