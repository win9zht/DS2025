#include <iostream>
#include <string>
#include <stack>
#include <cmath>
#include <stdexcept>
#include <sstream>
using namespace std;

#define N_OPTR 9
typedef enum {ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE} Operator;

const char pri[N_OPTR][N_OPTR] = {
'>', '>', '<', '<', '<', '<', '<', '>', '>',
'>', '>', '<', '<', '<', '<', '<', '>', '>',
'>', '>', '>', '>', '<', '<', '<', '>', '>',
'>', '>', '>', '>', '<', '<', '<', '>', '>',
'>', '>', '>', '>', '>', '<', '<', '>', '>',
'>', '>', '>', '>', '>', '>', ' ', '>', '>',
'<', '<', '<', '<', '<', '<', '<', '=', ' ',
' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
'<', '<', '<', '<', '<', '<', '<', ' ', '='
};

Operator charToOperator(char c) {
    switch (c) {
        case '+': return ADD;
        case '-': return SUB;
        case '*': return MUL;
        case '/': return DIV;
        case '^': return POW;
        case '!': return FAC;
        case '(': return L_P;
        case ')': return R_P;
        case '\0': return EOE;
        default: throw invalid_argument("无效的运算符: " + string(1, c));
    }
}

char getPriority(char stackTop, char current) {
    Operator topOp = charToOperator(stackTop);
    Operator curOp = charToOperator(current);
    return pri[topOp][curOp];
}

long long factorial(int n) {
    if (n < 0) throw invalid_argument("阶乘不能为负数");
    if (n == 0 || n == 1) return 1;
    long long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

double calculate(double a, double b, char op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/':
            if (b == 0) throw invalid_argument("除数不能为零");
            return a / b;
        case '^': return pow(a, b);
        default: throw invalid_argument("无效的二元运算符: " + string(1, op));
    }
}

double calculateUnary(double a, char op) {
    if (op == '!') {
        if (a < 0 || a != (int)a) throw invalid_argument("阶乘只能用于非负整数");
        return factorial((int)a);
    }
    throw invalid_argument("无效的一元运算符: " + string(1, op));
}

bool isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == '!' || c == '(' || c == ')';
}

bool isDigitOrDot(char c) {
    return isdigit(c) || c == '.';
}

class StringCalculator {
private:
    stack<char> opStack;
    stack<double> numStack;
    
    void processOperator(char op) {
        while (!opStack.empty() && getPriority(opStack.top(), op) == '>') {
            char topOp = opStack.top();
            opStack.pop();
            
            if (topOp == '!') {
                if (numStack.empty()) throw invalid_argument("表达式无效");
                double a = numStack.top();
                numStack.pop();
                numStack.push(calculateUnary(a, topOp));
            } else {
                if (numStack.size() < 2) throw invalid_argument("表达式无效");
                double b = numStack.top(); numStack.pop();
                double a = numStack.top(); numStack.pop();
                numStack.push(calculate(a, b, topOp));
            }
        }
        
        if (!opStack.empty() && getPriority(opStack.top(), op) == '=') {
            opStack.pop();
        } else {
            opStack.push(op);
        }
    }
    
public:
    double evaluate(const string& expression) {
        while (!opStack.empty()) opStack.pop();
        while (!numStack.empty()) numStack.pop();
        
        opStack.push('\0');
        
        size_t i = 0;
        string expr = expression + "\0";
        
        while (i < expr.length()) {
            if (isspace(expr[i])) {
                i++;
                continue;
            }
            
            if (isDigitOrDot(expr[i])) {
                string numStr;
                while (i < expr.length() && (isdigit(expr[i]) || expr[i] == '.')) {
                    numStr += expr[i++];
                }
                
                try {
                    double num = stod(numStr);
                    numStack.push(num);
                } catch (const exception& e) {
                    throw invalid_argument("无效的数字: " + numStr);
                }
                continue;
            }
            
            if (isOperator(expr[i]) || expr[i] == '\0') {
                if (expr[i] == '-' && (i == 0 || expr[i-1] == '(' || isOperator(expr[i-1]))) {
                    numStack.push(0);
                    processOperator('-');
                    i++;
                } else {
                    processOperator(expr[i]);
                    i++;
                }
                continue;
            }
            
            throw invalid_argument("无效的字符: " + string(1, expr[i]));
        }
        
        if (numStack.size() != 1 || !opStack.empty()) {
            throw invalid_argument("表达式无效");
        }
        
        return numStack.top();
    }
};

void testCalculator() {
    StringCalculator calc;
    
    vector<pair<string, double>> testCases = {
        {"1+2", 3},
        {"3-2", 1},
        {"2 * 3", 6},
        {"6/2", 3},
        {"2^3", 8},
        {"5!", 120},
        {"(1+2)*3", 9},
        {"2^3!", 64},
        {"3!+4", 10}
    };
    
    cout << "=== 字符串计算器测试案例 ===" << endl;
    for (const auto& testCase : testCases) {
        try {
            double result = calc.evaluate(testCase.first);
            cout << testCase.first << " = " << result;
            if (abs(result - testCase.second) < 1e-10) {
                cout << " ✓ 正确" << endl;
            } else {
                cout << " ✗ 错误，期望: " << testCase.second << endl;
            }
        } catch (const exception& e) {
            cout << testCase.first << " = 式子无效 (" << e.what() << ")" << endl;
        }
    }
    
    cout << "\n=== 无效表达式测试 ===" << endl;
    vector<string> invalidCases = {
        "1+",
        "+1",
        "1++2",
        "1/0",
        "(-1)!",
        "2.5!",
        "(1+2",
        "1+2)"
    };
    
    for (const auto& invalidCase : invalidCases) {
        try {
            double result = calc.evaluate(invalidCase);
            cout << invalidCase << " = " << result << " ✗ 应该无效" << endl;
        } catch (const exception& e) {
            cout << invalidCase << " = 式子无效 (" << e.what() << ") ✓" << endl;
        }
    }
}

int main() {
    try {
        testCalculator();
        
        cout << "\n=== 交互式测试 ===" << endl;
        cout << "输入表达式（输入quit退出）:" << endl;
        
        StringCalculator calc;
        string input;
        
        while (true) {
            cout << "> ";
            getline(cin, input);
            
            if (input == "quit") break;
            if (input.empty()) continue;
            
            try {
                double result = calc.evaluate(input);
                cout << "结果: " << result << endl;
            } catch (const exception& e) {
                cout << "错误: " << e.what() << endl;
            }
        }
        
    } catch (const exception& e) {
        cerr << "程序错误: " << e.what() << endl;
        return 1;
    }
    
    return 0;
}
